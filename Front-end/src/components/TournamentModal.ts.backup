// Tournament Bracket Modal for 4-player knockout
// This is a simple modal that collects 4 player names and displays a bracket

export function showTournamentBracketModal() {
  // Remove any existing modal
  let oldModal = document.getElementById('tournament-bracket-modal');
  if (oldModal) oldModal.remove();

  // Modal overlay
  const overlay = document.createElement('div');
  overlay.id = 'tournament-bracket-modal';
  overlay.className = 'modal-overlay';

  // Modal content
  const modal = document.createElement('div');
  modal.className = 'tournament-container';
  modal.innerHTML = `
    <button class="close-btn">×</button>
    <div class="bracket-preview">
      <svg viewBox="0 0 100 100">
        <path d="M20 20 L40 20 L40 35 L60 35 M40 35 L40 50 L20 50 M20 70 L40 70 L40 65 L60 65 M40 65 L40 80 L20 80 M60 35 L60 50 L80 50 M60 65 L60 50"/>
      </svg>
    </div>
    <h1 class="title">TOURNAMENT</h1>
    <p class="subtitle">4-PLAYER BRACKET SETUP</p>
    <div class="players-grid">
      <div class="player-slot">
        <span class="player-number">P1</span>
        <input type="text" class="player-input" placeholder="Player 1" maxlength="20">
      </div>
      <div class="player-slot">
        <span class="player-number">P2</span>
        <input type="text" class="player-input" placeholder="Player 2" maxlength="20">
      </div>
      <div class="player-slot">
        <span class="player-number">P3</span>
        <input type="text" class="player-input" placeholder="Player 3" maxlength="20">
      </div>
      <div class="player-slot">
        <span class="player-number">P4</span>
        <input type="text" class="player-input" placeholder="Player 4" maxlength="20">
      </div>
    </div>
    <div class="vs-indicator">VS</div>
    <button class="start-button" id="startBtn">⚡ Generate Bracket ⚡</button>
  `;

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // Add styles (only once)
  if (!document.getElementById('tournament-modal-styles')) {
    const style = document.createElement('style');
    style.id = 'tournament-modal-styles';
    style.textContent = `
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap');
      .tournament-container {
        font-family: 'JetBrains Mono', monospace;
        background: rgba(20, 20, 30, 0.95);
        border: 2px solid #00fff7;
        border-radius: 32px;
        padding: 48px 32px;
        max-width: 600px;
        width: 100%;
        position: relative;
        backdrop-filter: blur(18px) saturate(180%);
        box-shadow: 0 0 60px 0 #00fff7, 0 0 0 4px #222 inset;
        animation: slideIn 0.7s cubic-bezier(0.25,0.46,0.45,0.94);
        border-image: linear-gradient(135deg, #00fff7 0%, #ff00ea 100%) 1;
        overflow: hidden;
      }
      .close-btn {
        position: absolute;
        top: 18px;
        right: 28px;
        background: none;
        border: none;
        color: #00fff7;
        font-size: 32px;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'JetBrains Mono', monospace;
        text-shadow: 0 0 12px #00fff7, 0 0 2px #fff;
      }
      .close-btn:hover {
        color: #ff00ea;
        transform: rotate(90deg) scale(1.2);
        text-shadow: 0 0 24px #ff00ea;
      }
      .title {
        color: #00fff7;
        font-size: 38px;
        font-weight: 800;
        text-align: center;
        margin-bottom: 18px;
        text-shadow: 0 0 32px #00fff7, 0 0 8px #ff00ea;
        letter-spacing: 3px;
        background: linear-gradient(90deg, #00fff7 0%, #ff00ea 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .subtitle {
        color: #fff;
        text-align: center;
        margin-bottom: 36px;
        font-size: 16px;
        letter-spacing: 2px;
        opacity: 0.7;
      }
      .players-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 32px;
        margin-bottom: 48px;
      }
      .player-slot {
        position: relative;
        background: linear-gradient(135deg, rgba(0,255,247,0.08), rgba(255,0,234,0.08));
        border: 2px solid #222;
        border-radius: 18px;
        padding: 32px 20px;
        min-height: 120px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        box-shadow: 0 0 24px 0 #00fff7 inset;
        transition: box-shadow 0.3s, border-color 0.3s;
        opacity: 0;
        transform: translateY(24px);
        animation: fadeInUp 0.5s ease-out forwards;
      }
      .player-slot:nth-child(1) { animation-delay: 0.1s; }
      .player-slot:nth-child(2) { animation-delay: 0.2s; }
      .player-slot:nth-child(3) { animation-delay: 0.3s; }
      .player-slot:nth-child(4) { animation-delay: 0.4s; }
      .player-slot.filled {
        border-color: #00fff7;
        box-shadow: 0 0 32px 0 #ff00ea inset;
        background: linear-gradient(135deg, rgba(0,255,247,0.18), rgba(255,0,234,0.18));
      }
      .player-number {
        position: absolute;
        top: -16px;
        left: 24px;
        background: linear-gradient(135deg, #00fff7, #ff00ea);
        color: #222;
        font-size: 13px;
        font-weight: 700;
        padding: 8px 18px;
        border-radius: 24px;
        letter-spacing: 2px;
        box-shadow: 0 4px 16px #00fff7;
      }
      .player-input {
        background: rgba(255,255,255,0.08);
        border: none;
        color: #fff;
        font-size: 20px;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        outline: none;
        width: 100%;
        text-align: center;
        letter-spacing: 2px;
        border-radius: 8px;
        padding: 10px 0;
        box-shadow: 0 0 8px #00fff7 inset;
        transition: box-shadow 0.2s;
      }
      .player-input:focus {
        box-shadow: 0 0 16px #ff00ea inset;
      }
      .player-input::placeholder {
        color: #00fff7;
        font-weight: 400;
        opacity: 0.5;
      }
      .vs-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        background: linear-gradient(90deg, #00fff7 0%, #ff00ea 100%);
        color: #fff;
        font-size: 18px;
        font-weight: 800;
        padding: 10px 22px;
        border-radius: 32px;
        border: 2px solid #00fff7;
        pointer-events: none;
        z-index: 10;
        box-shadow: 0 0 24px #ff00ea;
        backdrop-filter: blur(8px);
      }
      .start-button {
        width: 100%;
        background: linear-gradient(90deg, #00fff7 0%, #ff00ea 100%);
        border: none;
        border-radius: 18px;
        padding: 22px;
        color: #222;
        font-size: 20px;
        font-weight: 800;
        font-family: 'JetBrains Mono', monospace;
        cursor: pointer;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 3px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 8px 32px #00fff7, 0 0 0 2px #ff00ea inset;
      }
      .start-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        transition: left 0.5s;
      }
      .start-button:hover {
        transform: translateY(-3px) scale(1.04);
        box-shadow: 0 15px 40px #ff00ea, 0 0 0 2px #00fff7 inset;
      }
      .start-button:hover::before {
        left: 100%;
      }
      .start-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        background: linear-gradient(90deg, #666 0%, #888 100%);
      }
      .start-button:disabled:hover {
        transform: none;
        box-shadow: 0 8px 25px #ff00ea;
      }
      .bracket-preview {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 80px;
        height: 80px;
        opacity: 0.12;
        pointer-events: none;
      }
      .bracket-preview svg {
        width: 100%;
        height: 100%;
        stroke: #00fff7;
        fill: none;
        stroke-width: 2;
      }
      @media (max-width: 640px) {
        .tournament-container { padding: 18px; margin: 10px; }
        .players-grid { gap: 14px; }
        .player-slot { padding: 14px 8px; min-height: 80px; }
        .title { font-size: 24px; }
        .player-input { font-size: 14px; }
      }
      @media (max-width: 480px) {
        .players-grid { grid-template-columns: 1fr; gap: 8px; }
        .vs-indicator { display: none; }
      }
      @keyframes slideIn {
        from { opacity: 0; transform: translateY(30px) scale(0.9); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      @keyframes fadeInUp {
        to { opacity: 1; transform: translateY(0); }
      }
      @keyframes slideOut {
        to { opacity: 0; transform: translateY(-30px) scale(0.9); }
      }
    `;
    document.head.appendChild(style);
  }

  // JS logic for modal
  const inputs = modal.querySelectorAll('.player-input') as NodeListOf<HTMLInputElement>;
  const startBtn = modal.querySelector('#startBtn') as HTMLButtonElement;
  const slots = modal.querySelectorAll('.player-slot');
  function updateSlotState(input: HTMLInputElement, slot: Element) {
    if (input.value.trim()) {
      slot.classList.add('filled');
    } else {
      slot.classList.remove('filled');
    }
  }
  function checkAllInputs() {
    const allFilled = Array.from(inputs).every(input => input.value.trim() !== '');
    startBtn.disabled = !allFilled;
    if (allFilled) {
      startBtn.innerHTML = '🏆 START TOURNAMENT 🏆';
    } else {
      startBtn.innerHTML = '⚡ GENERATE BRACKET ⚡';
    }
  }
  inputs.forEach((input, index) => {
    input.addEventListener('input', () => {
      updateSlotState(input, slots[index]);
      checkAllInputs();
    });
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const nextInput = inputs[index + 1];
        if (nextInput) {
          nextInput.focus();
        } else if (!startBtn.disabled) {
          startTournament();
        }
      }
    });
  });
  let currentTournamentId: number | undefined;
  async function startTournament() {
    if (startBtn.disabled) return;
    const players = Array.from(inputs).map(input => input.value.trim());
    console.log('[DEBUG] Players before starting tournament:', players);
    if (players.length < 2) {
      console.warn('[DEBUG] Not enough players to start tournament. Need at least 2, got', players.length);
      alert('You need at least 2 players to start a tournament.');
      return;
    }
    startBtn.innerHTML = '🔥 CREATING BRACKET... 🔥';
    startBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 50%, #15803d 100%)';
    // Create tournament in backend and get its id
    const { apiService } = await import('../services/api');
    try {
      const response = await apiService.tournaments.create('Knockout', 4, players);
      if (response.data && response.data.tournamentId) {
        currentTournamentId = response.data.tournamentId;
        console.log('[DEBUG] Tournament created with id:', currentTournamentId!);
        // Join all players before starting
        for (const alias of players) {
          const joinResp = await apiService.tournaments.join(currentTournamentId!, alias);
          console.log('[DEBUG] Joined player:', alias, joinResp);
        }
        // Start the tournament to generate matches
        const startResp = await apiService.tournaments.start(currentTournamentId!);
        if (startResp.error) {
          console.error('[DEBUG] Tournament start failed:', startResp.error);
          alert('Failed to start tournament.');
          return;
        } else {
          console.log('[DEBUG] Tournament started, matches:', startResp.data?.matches);
        }
      } else {
        console.error('[DEBUG] Tournament creation failed:', response.error);
        alert('Failed to create tournament.');
        return;
      }
    } catch (err) {
      console.error('[DEBUG] Error creating tournament:', err);
      alert('Error creating tournament.');
      return;
    }
    setTimeout(() => {
      overlay.remove();
      showBracket(players, currentTournamentId!);
      startBtn.innerHTML = '🏆 START TOURNAMENT 🏆';
      startBtn.style.background = 'linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffa500 100%)';
    }, 1200);
  }
  startBtn.addEventListener('click', startTournament);
  checkAllInputs();
  (inputs[0] as HTMLInputElement).focus();
  // Close button
  modal.querySelector('.close-btn')?.addEventListener('click', () => {
    modal.style.animation = 'slideOut 0.4s ease-in';
    setTimeout(() => overlay.remove(), 400);
  });
}

function showBracket(players: string[], tournamentId?: number) {
  // Helper to fetch matches for a tournament
  // @ts-ignore
  async function fetchTournamentMatches(tournamentId) {
  const { apiService } = await import('../services/api');
  // hanieh added: use tournaments.getById
  const response = await apiService.tournaments.getById(tournamentId);
  // Assume response.data.matches is an array of { matchId, player1, player2, round }
  return response.data && response.data.matches ? response.data.matches : [];
  }
  // Helper to show 'Back to Bracket' button after match ends
  function showBackToBracketButton() {
    // Create modal overlay
    let modal = document.getElementById('finished-game-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'finished-game-modal';
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100vw';
      modal.style.height = '100vh';
      modal.style.background = 'rgba(0,0,0,0.7)';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '9999';
      modal.innerHTML = `
        <div style="background:#1e293b;padding:2rem 2.5rem;border-radius:18px;box-shadow:0 8px 32px rgba(0,0,0,0.3);text-align:center;max-width:350px;">
          <h2 style="color:#fff;margin-bottom:1rem;">Game Finished!</h2>
          <p style="color:#cbd5e1;margin-bottom:2rem;">Match 1 is complete.<br>Click below to return to the bracket and start the next match.</p>
          <button id="back-to-bracket-btn" class="btn btn-primary" style="width:100%;font-size:1.1em;">Back to Bracket</button>
        </div>
      `;
      document.body.appendChild(modal);
      // Button event
      const btn = modal.querySelector('#back-to-bracket-btn');
      if (btn) {
        btn.addEventListener('click', () => {
          modal?.remove();
          const app = document.getElementById('app');
          if (app) app.innerHTML = '';
          showBracketWithProgress(players, matchWinners);
        });
      }
    }
  }

  // Helper to restore bracket with progress
  function showBracketWithProgress(players: string[], winners: { [key: string]: string }) {
    // Remove any existing bracket
    let oldBracket = document.getElementById('tournament-bracket-ui');
    if (oldBracket) oldBracket.remove();
    // Recreate bracket and restore winners
    showBracket(players);
    // Restore winners visually
    Object.keys(winners).forEach(key => {
      if (key === '1' || key === '2') {
        const matchPlayers = document.querySelectorAll(`.match[data-match="${key}"] .player`);
        matchPlayers.forEach(p => {
          if (p.getAttribute('data-player') === winners[key]) {
            p.classList.add('winner');
          }
        });
      }
    });
    // Restore finalists
    const finalPlayers = document.querySelectorAll('.final-match .player');
    if (winners['1']) {
      finalPlayers[0].textContent = winners['1'];
      finalPlayers[0].classList.remove('placeholder');
      finalPlayers[0].setAttribute('data-player', winners['1']);
    }
    if (winners['2']) {
      finalPlayers[1].textContent = winners['2'];
      finalPlayers[1].classList.remove('placeholder');
      finalPlayers[1].setAttribute('data-player', winners['2']);
    }
    // Restore champion if exists
    if (winners['final']) {
      setTimeout(() => {
        alert(`🏆🎉 TOURNAMENT CHAMPION 🎉🏆\n\n${winners['final'].toUpperCase()}\n\nCongratulations on your victory!\n\n🥇 You are the ultimate champion! 🥇`);
      }, 600);
    }
  }
  // Remove any existing bracket
  let oldBracket = document.getElementById('tournament-bracket-ui');
  if (oldBracket) oldBracket.remove();

  // Bracket container
  const bracket = document.createElement('div');
  bracket.id = 'tournament-bracket-ui';
  bracket.innerHTML = `
    <div class="tournament-container">
      <div class="tournament-header">
        <h1 class="tournament-title"><span class="trophy">🏆</span> TOURNAMENT BRACKET</h1>
        <p class="tournament-subtitle">✨ 4-Player Single Elimination Championship ✨</p>
      </div>
      <div class="bracket-container">
        <div class="semifinals-column">
          <div class="match" data-match="1">
            <div class="match-header">🥊 Match 1 - Semifinal</div>
            <div class="match-players">
              <div class="player" data-player="${players[0]}">${players[0]}</div>
              <div class="vs-divider">VS</div>
              <div class="player" data-player="${players[1]}">${players[1]}</div>
            </div>
            <div class="start-match-btn-container">
              <button class="btn btn-primary start-match-btn" data-match="1">Start Match</button>
            </div>
          </div>
          <div class="match" data-match="2">
            <div class="match-header">🥊 Match 2 - Semifinal</div>
            <div class="match-players">
              <div class="player" data-player="${players[2]}">${players[2]}</div>
              <div class="vs-divider">VS</div>
              <div class="player" data-player="${players[3]}">${players[3]}</div>
            </div>
            <div class="start-match-btn-container">
              <button class="btn btn-primary start-match-btn" data-match="2">Start Match</button>
            </div>
          </div>
        </div>
        <div class="bracket-lines">
          <svg viewBox="0 0 100 100" preserveAspectRatio="none">
            <path class="connection-line" id="line1" d="M 25 25 L 50 25 L 50 50 L 75 50" />
            <path class="connection-line" id="line2" d="M 25 75 L 50 75 L 50 50 L 75 50" />
          </svg>
        </div>
        <div class="final-column">
          <div class="match final-match" data-match="final">
            <div class="match-header">🏆 CHAMPIONSHIP FINAL 🏆</div>
            <div class="match-players">
              <div class="player placeholder" data-from="match1">Winner of Match 1</div>
              <div class="vs-divider">VS</div>
              <div class="player placeholder" data-from="match2">Winner of Match 2</div>
            </div>
          </div>
        </div>
      </div>
      <!-- controls removed -->
    </div>
  `;
  // Add start match button logic
  const startBtns = bracket.querySelectorAll('.start-match-btn');
  const match2Btn = bracket.querySelector('.start-match-btn[data-match="2"]') as HTMLButtonElement;
  // Initially disable Match 2 button
  if (match2Btn) {
    match2Btn.disabled = true;
    match2Btn.style.opacity = '0.5';
    match2Btn.title = 'Finish Match 1 first';
  }
  startBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const matchNum = (btn as HTMLButtonElement).getAttribute('data-match');
      // Prevent Match 2 if Match 1 not finished
      if (matchNum === '2' && !matchWinners[1]) {
        (btn as HTMLButtonElement).disabled = true;
        (btn as HTMLButtonElement).style.opacity = '0.5';
        (btn as HTMLButtonElement).title = 'Finish Match 1 first';
        alert('You must finish Match 1 before starting Match 2!');
        return;
      }
      // Get the two player names for this match
      let playerA = '', playerB = '';
      if (matchNum === '1') {
        playerA = players[0];
        playerB = players[1];
      } else if (matchNum === '2') {
        playerA = players[2];
        playerB = players[3];
      }
      // Call your real game logic here
      startGame(playerA, playerB, matchNum);
    });
  });
  // Enable Match 2 button when Match 1 is finished
  function enableMatch2IfReady() {
    if (match2Btn && matchWinners[1]) {
      match2Btn.disabled = false;
      match2Btn.style.opacity = '1';
      match2Btn.title = '';
    }
  }
  // Patch selectWinner to enable Match 2 when Match 1 is done
  const originalSelectWinner = selectWinner;
  selectWinner = function(playerElement, matchNumber) {
    originalSelectWinner(playerElement, matchNumber);
    enableMatch2IfReady();
  };

  // Real game integration stub
  function startGame(playerA: string, playerB: string, matchNum: string | null) {
    // Launch the real pong game in the current view
    const app = document.getElementById("app");
    if (app) {
      let gameContainer = document.getElementById("game-container-wrapper") as HTMLElement;
      if (!gameContainer) {
        gameContainer = document.createElement("div");
        gameContainer.id = "game-container-wrapper";
        gameContainer.className = "game-container-wrapper";
        app.innerHTML = '';
        app.appendChild(gameContainer);
      } else {
        gameContainer.innerHTML = '';
      }
      // Create navigation back function
      const navigateBack = () => {
        window.location.reload(); // Or navigate to tournament page if you want
      };
      // Use tournamentId from context
      const effectiveTournamentId = tournamentId || currentTournamentId;
      if (!effectiveTournamentId) {
        console.error('[DEBUG] No tournamentId available for match start.');
        alert('Tournament ID missing. Cannot start match.');
        return;
      }
      // Fetch matches using apiService.tournaments.getById
      import('../services/api').then(({ apiService }) => {
  apiService.tournaments.getById(effectiveTournamentId).then(response => {
          const matches = response.data && response.data.matches ? response.data.matches : [];
          console.log('[DEBUG] Matches from backend:', matches);
          // hanieh added: filter by tournament_id
          const filteredMatches = matches.filter(m => m.tournament_id === effectiveTournamentId);
          console.log('[DEBUG] Filtered matches:', filteredMatches);
          const match = filteredMatches.find(m => {
            const found = ((m.player1 === playerA && m.player2 === playerB) || (m.player1 === playerB && m.player2 === playerA)) && m.round === matchNum;
            if (found) {
              console.log('[DEBUG] Found match:', m);
            }
            return found;
          });
          if (!match) {
            console.warn('[DEBUG] No match found for', { playerA, playerB, matchNum });
          }
          const matchId = match ? (match.matchId || match.id) : undefined;
          if (!matchId) {
            console.warn('[DEBUG] No valid matchId found, will not start game or submit result.', { match, playerA, playerB, matchNum });
            return;
          }
          console.log('[DEBUG] Using matchId:', matchId);
          import('../gamePage').then(({ create1v1GamePage }) => {
            // Set tournament flags to block modal
            (window as any).currentTournamentMatch = true;
            (window as any).gamePageSuppressModal = true;
            (window as any).gamePageMode = 'tournament';
            const gamePage = create1v1GamePage(gameContainer, navigateBack);
            if (gamePage.setPlayerNames) {
              gamePage.setPlayerNames(playerA, playerB);
            }
            // Set the real matchId for result submission
            if (gamePage.game) {
              gamePage.game.matchId = matchId;
            }
            // Listen for game end event and show modal only after game is finished
            if (gamePage && gamePage.game && typeof gamePage.game.onGameEndCallback === 'function') {
              gamePage.game.onGameEndCallback(() => {
                // After match ends, disable button and show back button/modal
                delete (window as any).currentTournamentMatch;
                delete (window as any).gamePageSuppressModal;
                delete (window as any).gamePageMode;
                // Get scores and matchId for result submission
                const tournamentId = effectiveTournamentId;
                let matchId: number | undefined;
                let player1Score: number | undefined;
                let player2Score: number | undefined;
                if (gamePage && gamePage.game) {
                  matchId = typeof gamePage.game.matchId === 'number' ? gamePage.game.matchId : undefined;
                  const players = gamePage.game.getPlayers?.();
                  if (players && players.player1 && players.player2) {
                    player1Score = typeof players.player1.score === 'number' ? players.player1.score : undefined;
                    player2Score = typeof players.player2.score === 'number' ? players.player2.score : undefined;
                  }
                }
                console.log('[DEBUG] Submitting tournament match result:', { matchId, tournamentId, player1Score, player2Score });
                if (
                  typeof matchId === 'number' &&
                  typeof player1Score === 'number' &&
                  typeof player2Score === 'number'
                ) {
                  import('../services/api').then(({ apiService }) => {
                    apiService.tournaments.submitMatchResult(tournamentId, matchId, player1Score, player2Score)
                      .then(({ data, error }) => {
                        if (error) {
                          console.error('[DEBUG] Error sending tournament match result:', error);
                        } else {
                          console.log('[DEBUG] Tournament match result sent successfully:', data);
                          window.dispatchEvent(new Event('reloadDashboardStats'));
                        }
                      })
                      .catch((err) => {
                        console.error('[DEBUG] Error sending tournament match result (catch):', err);
                      });
                  });
                } else {
                  console.warn('[DEBUG] Missing matchId or scores, cannot send tournament match result to backend', {
                    matchId,
                    tournamentId,
                    player1Score,
                    player2Score
                  });
                }
                if (matchNum === '1') {
                  const match1Btn = document.querySelector('.start-match-btn[data-match="1"]') as HTMLButtonElement;
                  if (match1Btn) {
                    match1Btn.disabled = true;
                    match1Btn.style.opacity = '0.5';
                    match1Btn.title = 'Match 1 is finished';
                  }
                }
                showBackToBracketButton();
              });
            }
          });
        });
      });
    }
  }

  // Add styles (only once)
  if (!document.getElementById('tournament-bracket-styles')) {
    const style = document.createElement('style');
    style.id = 'tournament-bracket-styles';
    style.textContent = `
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
      .tournament-container { font-family: 'Inter', sans-serif; background: none; max-width: 1000px; width: 100%; color: white; }
      .tournament-header { text-align: center; margin-bottom: 60px; }
      .tournament-title { font-size: 42px; font-weight: 700; background: linear-gradient(135deg, #00d4ff, #0ea5e9); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 10px; }
      .tournament-subtitle { font-size: 16px; color: rgba(255,255,255,0.6); font-weight: 500; }
      .bracket-container { display: flex; align-items: center; justify-content: center; gap: 100px; position: relative; min-height: 500px; }
      .semifinals-column { display: flex; flex-direction: column; gap: 60px; }
      .final-column { display: flex; align-items: center; }
      .match { background: rgba(30,41,59,0.9); border: 2px solid rgba(59,130,246,0.4); border-radius: 16px; backdrop-filter: blur(10px); transition: all 0.3s; overflow: hidden; width: 280px; animation: slideIn 0.7s ease-out forwards; opacity: 0; transform: translateY(40px); }
      .match:hover { border-color: rgba(0,212,255,0.7); transform: translateY(-3px); box-shadow: 0 15px 30px rgba(0,212,255,0.2); }
      .match-header { background: linear-gradient(135deg, rgba(59,130,246,0.8), rgba(147,51,234,0.8)); padding: 14px 20px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 1.5px; text-transform: uppercase; }
      .match-players { padding: 24px; }
      .player { display: flex; align-items: center; justify-content: center; padding: 18px 20px; background: rgba(15,23,42,0.7); border: 2px solid rgba(71,85,105,0.4); border-radius: 12px; margin-bottom: 14px; font-weight: 600; font-size: 16px; transition: all 0.3s; cursor: pointer; min-height: 65px; position: relative; }
      .player:last-child { margin-bottom: 0; }
      .player:hover { background: rgba(59,130,246,0.15); border-color: rgba(59,130,246,0.6); transform: translateX(8px); }
      .player.winner { background: rgba(34,197,94,0.2); border-color: rgba(34,197,94,0.7); color: #10b981; transform: translateX(8px); }
      .player.winner::after { content: '✓'; position: absolute; right: 15px; font-size: 20px; color: #10b981; }
      .player.placeholder { color: rgba(255,255,255,0.4); font-style: italic; cursor: default; border-style: dashed; }
      .player.placeholder:hover { background: rgba(15,23,42,0.7); border-color: rgba(71,85,105,0.4); transform: none; }
      .vs-divider { text-align: center; font-weight: 700; color: rgba(147,51,234,0.9); font-size: 14px; margin: 12px 0; letter-spacing: 2px; }
      .match.final-match { border-color: rgba(255,215,0,0.7); background: rgba(30,41,59,0.95); width: 320px; }
      .match.final-match:hover { border-color: rgba(255,215,0,0.9); box-shadow: 0 15px 30px rgba(255,215,0,0.3); }
      .match.final-match .match-header { background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(245,158,11,0.9)); color: #1a1a2e; font-size: 14px; }
      .bracket-lines { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; }
      .bracket-lines svg { width: 100%; height: 100%; }
      .connection-line { stroke: rgba(59,130,246,0.5); stroke-width: 3; fill: none; transition: all 0.3s; }
      .connection-line.active { stroke: rgba(0,212,255,0.9); stroke-width: 4; filter: drop-shadow(0 0 8px rgba(0,212,255,0.4)); }
      .controls { text-align: center; margin-top: 50px; display: flex; gap: 20px; justify-content: center; }
      .btn { padding: 14px 28px; border: none; border-radius: 12px; font-weight: 600; cursor: pointer; transition: all 0.3s; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; }
      .btn-primary { background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: white; }
      .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 10px 25px rgba(59,130,246,0.3); }
      .btn-secondary { background: rgba(71,85,105,0.7); color: white; border: 2px solid rgba(148,163,184,0.4); }
      .btn-secondary:hover { background: rgba(71,85,105,0.9); transform: translateY(-2px); }
      @media (max-width: 768px) { .bracket-container { flex-direction: column; gap: 50px; } .tournament-title { font-size: 32px; } .match { width: 100%; max-width: 300px; } .match.final-match { width: 100%; max-width: 320px; } .bracket-lines { display: none; } .controls { flex-direction: column; align-items: center; gap: 15px; } }
      .match { animation: slideIn 0.7s ease-out forwards; opacity: 0; transform: translateY(40px); }
      .semifinals-column .match:nth-child(1) { animation-delay: 0.2s; }
      .semifinals-column .match:nth-child(2) { animation-delay: 0.4s; }
      .final-column .match { animation-delay: 0.6s; }
      @keyframes slideIn { to { opacity: 1; transform: translateY(0); } }
    `;
    document.head.appendChild(style);
  }

  // Place in app
  const app = document.getElementById('app');
  if (app) {
    app.innerHTML = '';
    app.appendChild(bracket);
  } else {
    document.body.appendChild(bracket);
  }

  // Interactive logic
  let matchWinners: { [key: string]: string } = {};
  function selectWinner(playerElement: HTMLElement, matchNumber: string | number) {
    // Remove winner class from both players in this match
    const match = playerElement.closest('.match');
    if (!match) return;
    const players = match.querySelectorAll('.player:not(.placeholder)');
    players.forEach(p => p.classList.remove('winner'));
    // Add winner class to selected player
    playerElement.classList.add('winner');
    // Store winner
    const playerName = playerElement.getAttribute('data-player') || '';
    matchWinners[matchNumber] = playerName;
    // Update final match
    updateFinalMatch();
    // Activate connection line
    const lineId = `line${matchNumber}`;
    const line = document.getElementById(lineId);
    if (line) {
      line.classList.add('active');
      setTimeout(() => {
        line.classList.add('active');
      }, 100);
    }
  }
  function updateFinalMatch() {
    const finalPlayers = bracket.querySelectorAll('.final-match .player');
    // Update first finalist
    if (matchWinners[1]) {
      finalPlayers[0].textContent = matchWinners[1];
      finalPlayers[0].classList.remove('placeholder');
      finalPlayers[0].setAttribute('data-player', matchWinners[1]);
      (finalPlayers[0] as HTMLElement).onclick = () => selectWinner(finalPlayers[0] as HTMLElement, 'final');
    }
    // Update second finalist
    if (matchWinners[2]) {
      finalPlayers[1].textContent = matchWinners[2];
      finalPlayers[1].classList.remove('placeholder');
      finalPlayers[1].setAttribute('data-player', matchWinners[2]);
      (finalPlayers[1] as HTMLElement).onclick = () => selectWinner(finalPlayers[1] as HTMLElement, 'final');
    }
    // Check for tournament champion
    if (matchWinners['final']) {
      setTimeout(() => {
        showChampionAlert(matchWinners['final']);
      }, 600);
    }
  }
  function showChampionAlert(champion: string) {
    alert(`🏆🎉 TOURNAMENT CHAMPION 🎉🏆\n\n${champion.toUpperCase()}\n\nCongratulations on your victory!\n\n🥇 You are the ultimate champion! 🥇`);
  }
  function resetTournament() {
    matchWinners = {};
    // Reset all players
    bracket.querySelectorAll('.player').forEach(player => {
      player.classList.remove('winner');
    });
    // Reset final match players
    const finalPlayers = bracket.querySelectorAll('.final-match .player');
    finalPlayers[0].textContent = 'Winner of Match 1';
    finalPlayers[0].className = 'player placeholder';
    (finalPlayers[0] as HTMLElement).onclick = null;
    finalPlayers[0].removeAttribute('data-player');
    finalPlayers[1].textContent = 'Winner of Match 2';
    finalPlayers[1].className = 'player placeholder';
    (finalPlayers[1] as HTMLElement).onclick = null;
    finalPlayers[1].removeAttribute('data-player');
    // Reset connection lines
    bracket.querySelectorAll('.connection-line').forEach(line => {
      line.classList.remove('active');
    });
  }
  // @ts-ignore
  function newTournament() {
    if (confirm('🔄 Start a completely new tournament?\n\nThis will reset all progress.')) {
      resetTournament();
      alert('🆕 New tournament ready!\n\nGood luck to all players! 🍀');
    }
  }
  // Attach event listeners
  // Semifinal player click
  const match1Players = bracket.querySelectorAll('.match[data-match="1"] .player');
  match1Players.forEach(p => (p as HTMLElement).onclick = () => selectWinner(p as HTMLElement, 1));
  const match2Players = bracket.querySelectorAll('.match[data-match="2"] .player');
  match2Players.forEach(p => (p as HTMLElement).onclick = () => selectWinner(p as HTMLElement, 2));
  // controls removed
}

// @ts-ignore
function createMatchBox(playerA: string, playerB: string, label: string, isFinal: boolean = false) {
  const box = document.createElement('div');
  box.className = isFinal ? 'match finals-match' : 'match';
  box.innerHTML = `
    <div class="match-header">${label}</div>
    <div class="players">
      <div class="player">${playerA}</div>
      <div class="vs">vs</div>
      <div class="player">${playerB}</div>
    </div>
  `;
  return box;
}
